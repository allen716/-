# 1.背景

前后端分离概念之前，一个网站的完成总是“all in one“：页面、数据、渲染全部在服务端完成。

**弊端：**难以维护，开发人员必须同时具备前后端知识

**改进：**前后端分离：后端负责处理、组装、传递数据；前端负责数据的渲染。

**关键：**如何设计出一个便于理解、使用的API？

​          --- RESTful就是用来规范我们的API设计的一种约束。



# 2.设计思想

## 2.1概念

**Rest = Representational State Transfer** **--- **软件架构风格（面向资源）

**资源（Resource）**--- 核心：

网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。--- 什么是资源

你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。---怎么获取资源

**表现层（Representation）**：

"资源"是一种信息实体，它可以有多种外在表现形式。我们把"资源"具体呈现出来的形式，叫做它的"表现层"（Representation）。--- 我的理解：载体

例如：文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式

**状态转化（State Transfer）**：

访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生"状态转化"（State Transfer）。而这种转化是建立在表现层之上的，所以就是"表现层状态转化"。

URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的".html"后缀名是不必要的，因为这个后缀名表示格式，属于"表现层"范畴，而URI应该只代表"资源"的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对"表现层"的描述。

------

**个人理解**：

（1）后端：提供的所有内容（数据），都可以被定义为资源  --- 提供资源

（2）前端：连接用户与资源，使用户能以最简单的方式调度后端资源，并将调度结果以用户最容易接受的方式呈现出来     --- 调度资源

## 2.2核心内容

### 2.2.1 要点

**1.每一个URI代表一种资源。**

**2.客户端和服务器之间，传递这种资源的某种表现层（载体：json/xml）；** 

**3.客户端通过四个HTTP动词（get、post、put、delete），对服务器端资源进行操作，实现”表现层状态转化”。**

### **2.2.2 目的**

概括一下（源自知乎某大神）：

- 看 Url 就知道要什么   									--- 什么资源
- 看 http method 就知道干什么                      --- 做什么
- 看 http status code 就知道结果如何            --- 结果怎样



# 3.RESTful API 设计规范

## 3.1 方针

总方针：构建易于理解和使用的`RESTful`接口。

主要策略有：

（1）使用标准`HTTP`动词--围绕这些`HTTP`动词(`GET`/`PUT`/`POST`/`PATCH`和`DELETE`)对基本的行为进行建模。

（2）使用`URI`传达意图--使用`URI`来描述问题域中的不同资源，并为问题域内的资源的关系提供一种基本机制。

（3）使用`JSON`进行响应--`JSON`是一种轻量级的数据序列化协议。

（4）使用`HTTP`状态码来传达结果--`HTTP`协议具有丰富的标准响应代码，来指示服务的成功和失败。学习这些状态码，并且，最重要的是，在所有接口中始终如一地使用它们。

## 3.2 具体规范

总结的一些常见的规范：

### **3.2.1 协议**

​	API 与用户的通信协议，总是使用 HTTPS 协议

### 3.2.2 域名

​	尽量将 API 部署在专用域名，避免跨域问题

### 3.2.3 版本

三种方式：（转自: https://www.jianshu.com/p/215a6f73ef29）

1. `URI`中：`/api/v1/**`
2. `Accept Header`: `Accept: application/json+v1`
3. 自定义`Header`: `X-Api-Version: 1`

观点一：建议第一种，虽然没那么优雅，但最明显方便。

观点二：一个资源，应只有一个单一的`URI`来标示，资源版本不应该体现在`URI`中。

### 3.2.4 URL*

动宾形式 --- 对谁？要做什么？

#### 3.2.4.1 名词代表资源（who）

​	一切都是资源，均使用名词表示（建议复数），如：https://api.qinyilun.com/v1/projects

​	为什么要用名词？为什么要用复数？原因：

（1）url中不能有动词，**只能有名词**，所用的名词往往与数据库的表格名对应（名词--数据库--资源）

（2）数据库中的表一般都是同种记录的"集合"（collection），所以API中的名词也**应该使用复数**。

#### 3.2.4.2 动词代表做什么（what）

​	GET（SELECT）：从服务器取出资源（一项或多项）

​	POST（CREATE）：在服务器新建一个资源

​	PUT（UPDATE）：在服务器更新资源（客户端提供完整资源数据）

​	PATCH（UPDATE）：在服务器更新资源（客户端提供需要修改的资源数据）

​	DELETE（DELETE）：从服务器删除资源

------

**特别说明：请求间的异同？**https://www.jianshu.com/p/bee85cf4e33a

- POST和PUT

  共同点：两者其实都有创建指定资源的语义。

  不同点：

  POST是非幂等的,多次调用会产生不同的结果,比如:创建一个用户,由于网络原因或是其他原因多创建了几次,那么将会有多个用户被创建；（后一个请求不会把上一个请求覆盖掉） --- 所以主要用于新增资源的场景

  PUT是幂等的，而PUT id/456则会创建一个id为456的用户,多次调用还是会创建的结果是一样的,所以PUT是幂等的。（后一个请求会覆盖掉上一个请求） ---所以主要用于更改资源的场景

- PUT和PATCH

  不同点：

  （1）PUT：更新完整的资源对象，Patch：局部更新资源（部分属性）

  ​	场景: 有一个UserInfo，里面有userId， userName， userGender等字段。可因为需求限制，在某个特别				的页面里只能修改userName，这时候的更新怎么做？

  ​	方法一：为了省事，可以把一个包含了修改后userName的完整userInfo对象传给后端，做完整更新。但这					样其实把很多不必要的字段也穿过去了，造成了浪费。

  ​	方法二：通过PATCH请求，只传一个userName到指定资源去，表示该请求是一个局部更新，后端仅更新接					收到的字段。
  
  （2）PUT会有一个create操作，假如更新的id不存在，会进行创建，而PATCH则没有这个.

### 3.2.5 过滤条件*

​	通过在 url 上传参的形式传递搜索条件. 

错误egs:   /projects/001/release-units/007    ----  这种URI不易于扩展，语义也不明确

正确egs:  /projects/001?release-units=007

类似的，实现排序、投影和分页等：

（1）https://api.qinyilun.com/v1/projects?limit=10：指定返回记录的数量

（2）https://api.qinyilun.com/v1/projectsets/projects?id=007：指定筛选条件

### 3.2.6 返回的数据格式

​	服务器返回的数据格式，应该尽量使用JSON（轻量级的数据序列化协议），避免使用XML

### 3.2.7 状态码

当`GET`, `PUT`和`PATCH`请求成功时，要返回对应的数据，及状态码`200`，即SUCCESS

当`POST`创建数据成功时，要返回创建的数据，及状态码`201`，即CREATED

当`DELETE`删除数据成功时，不返回数据，状态码要返回`204`，即NO CONTENT

当`GET` 不到数据时，状态码要返回`404`，即NOT FOUND

任何时候，如果请求有问题，如校验请求数据时发现错误，要返回状态码 `400`，即BAD REQUEST

当API 请求需要用户认证时，如果request中的认证信息不正确，要返回状态码 `401`，即NOT AUTHORIZED

当API 请求需要验证用户权限时，如果当前用户无相应权限，要返回状态码 `403`，即FORBIDDEN

------

常见错误码：

```css
200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。
201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。
202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）
204 NO CONTENT - [DELETE]：用户删除数据成功。
400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。
401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。
403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。
404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。
406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。
410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。
422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。
500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。
502 网关错误
503 Service Unavailable
504 网关超时
```

### 3.2.8 错误处理

状态码反映发生的错误，而具体的错误信息放在数据体

```dart
HTTP/1.1 400 Bab Request
Content-Type: application/json

{
    "error": "Invalid param."
    "data": {
        "name": "This field is required."
    }
}
```

### 3.2.9 书写格式规范*

**（1）Url是区分大小写的**

这点经常被忽略，即：

- `/Posts`
- `/posts`

**（2）连接符 `-` 和 下划线 `_`**

RESTful API 应具备良好的可读性，当url中某一个片段（segment）由多个单词组成时，建议使用 `-` 来隔断单词，而不是使用 `_`，即：

```
# Good
/api/qinyilun-post/

# Bad
/api/qinyilun_post/复制代码
```

**原因：浏览器中超链接默认显示效果：[文字并附带下划线](http://blog.igevin.info)，如果API以`_`隔断单词，二者会重叠，影响可读性。**

错误示例：<u>/api/qinyilun_post</u>

### 3.2.10 速率限制 #

响应头建议包含当前限流状态

如 GitHub api 中使用3个相关的头信息进行说明：

- `X-RateLimit-Limit`: 用户在时间窗口下发送请求的最大值
- `X-RateLimit-Remaining`: 当前时间窗口剩下的可用请求数
- `X-RateLimit-Rest`: 为了得到最大请求数(或到下一时间窗口)所等待的秒数

建议同时提供可以不影响`RateLimit`的请求接口，来查询当前的`RateLimit`。

# 4.参考文章

简书：https://www.jianshu.com/p/215a6f73ef29

阮一峰博客：http://www.ruanyifeng.com/blog/2014/05/restful_api.html

简书：https://www.jianshu.com/p/bee85cf4e33a

